没公开的题目为口胡，JOISC2022 Day4T1 之前做过，略去不记

# CF1458C

注意行/列排列求逆是对所有行/列做，所以完成变换之后仍然是拉丁方阵；同时在行/列左移右移的过程中也都是全体操作，那么全局变换作用于单点必然有规律

考察一维中变成逆排列本质上是将每个位置具有的二元组 $(i,p_i)$ 变成 $(p_i,i)$，而下标加减可以通过维护标记实现

把这东西推广到三维即可，维护输入完就确定下来的三元组 $(i,j,a_{i,j})$ 和当前三元组的相对顺序，同时维护两个标号加法标记即可通过 $n^2$ 个三元组还原最终矩阵

# CFGym103069C

可以通过输入的 $a_i$ 还原每个 $i\in[1,n],\rm rand_i\bmod\ i$，对于 $n>50$ 的情况，先把最后 $n-50$ 轮进行逆操作，即在计算答案的过程中只利用前 $50$ 轮交换中每个 $rand_i\bmod\ i$ 提供的信息

将 $x$ 写成二进制 $\overline{x_{63}\dots x_{0}}$ ，可以模拟题中异或操作得到第 $i$ 次 rand 返回的数值 $\rm rand_i$ 的每个二进制位是由哪些 $x_i$ 异或得到（一开始设 `X[i]=pow(2,i)`，每次调用函数等价于 `X[i]^=X[i-13],X[i]^=X[i+7],X[i]^=X[i-17]` ）

注意当 $i$ 是偶数时，$\rm rand_i\bmod \ i$ 和 $\rm rand_i$ 的二进制表示中最后一位一致，那么通过上面维护出来的最后一位对应哪些 $x_i$ 异或起来得到一个方程，类似的，如果 $x\equiv 0\bmod 2^k$ 那么至少能得到 $k$ 个方程

但是有主元的方程只有 $\frac{50}{2}+\frac{50}{4}+\frac{50}{8}+\frac{50}{16}+\frac{50}{32}=47$ 个，不过剩下的可以暴力枚举，所以复杂度约为 $\Theta(50\times2^{17})$

使用线性基把这些方程消成上三角，注意每个有主元的元素的 $x_i$ 需要依赖其前面确定的 $x_i$ 的数值

（为什么方程线性无关？因为消出来确实无关，不会证明）

# THUPC2021F

将奇怪的六向网格变成 $x,y$ 轴和直线 $y=x$，那么可以设 $f_{i,j,k,X,Y}$ 表示进行了前 $i$ 个操作到了坐标 $(j,k)$，维护的变量数值为 $X,Y$ 是否可达，不过直接背包就算使用 `bitset` 也救不活

注意到 $n$ 次操作顺序无所谓，而且**最终需要回到原点**，那么将操作顺序随机打乱后，期望意义下 可以让 $X,Y$ 变成 $X_0,Y_0$ 的选择方式 中存在一种使得坐标大小不超过 $\sqrt n$，那么将记录坐标的维度开到 $\sqrt n$ 即可，实测开 $[-15,15]$ 能过

# [2022 集训队互测] Were You Last

题意简述：实现一个不依赖任何全局变量的函数 `bool solve(n,m)` 满足当且仅当第 $n$ 次调用其时返回 `true`，而 $m=10^5$ 是给定的可以修改的 $01$ 变量数，这些 $01$ 变量重复传入，但是每次只能读取&修改其中 $6$ 位

$m=10^5$ 是诈骗，最多只能操作 $2^6$ 的位置

维护 $27$ 个 $\rm bit$ 的二进制数和一个长度为 $5$ 个二进制 $\rm bit$ 的十进制指针 $i$（初始是 $0$），每次调用函数，读取五位指针和其指示的 $\rm bit$ 上的数值并翻转，如果翻转后该 $\rm bit$ 是 $1$ 就让十进制指针变成 $1$，否则变成 $i+1$。

此时第一次到达第 $x$ 个位置的时间就是 $2^x$

我在上学通勤的时候用来消遣的个人游戏就是按照二进制进位变化翻转左右手（练练协调性），但是大佬就可以翻转 6 只手还能出 OI 题！

# CF1568F

答案下界是 $\lceil \log_k n\rceil$ ，必要性显然

一种构造就是将 $k$ 个点用同颜色的边连成一条链，如果弱联通块数量大于 $1$ 就使用第二种颜色将 每 $k$ 个弱联通块揉到一起，没连边的就从编号小的点连向大的点，注意是 $1\sim k^2,k^2\sim 2k^2$ 这样分组，以此类推；所以两点连边可以的颜色可以用对数得到

其实仿照上述归纳可以得到下界的充分性证明

# CF1400D

计算以每个点 $(i,j)$ 左上方和它 切比雪夫距离 最小的 $q+1$ 种颜色和切比雪夫距离值，这可以对 $(i-1,j),(i-1,j-1),(i,j-1)$ 进行归并排序来处理

重复的点在归并排序的时候开个数组就能只记录一个，这就得到了以 $(i,j)$ 为右下角的合法正方形的边长：自己两维度坐标较小者和第 $q+1$ 个颜色对应点和它的切比雪夫距离，差分即可

# Luogu6383

让 $G,T$ 都以点 $n$ 为根规定深度父亲等信息，那么题述构造方式 $G$ 中每个点的父亲都是 $T$ 中它的祖先

注意到不可能存在 $G$ 中两条边 $(a,b),(c,d)$ 满足 $T$ 中 $(a,b),(c,d)$ 有交但是不包含，充分性可以选择深度最大的儿子断开两边递归

据此计数就是 $f_{i,j}$ 表示 $i$ 选完父亲之后 $i$ 的儿子还有 $j$ 个祖先可以选，转移为$\displaystyle f_{i,j}=\prod_{v\in son_u}\sum_{p=0}^{j+1}f_{v,p}$，前缀和优化即可做到 $\Theta(n^2)$ 复杂度

# [Unknown Source] lcm

题意简述：给定 $n\le 10^4$ 的序列 $a(a_i\le 10^{18})$，求一个字典序最小的序列 $b$，满足 $\forall i\in[1,n],b_i|a_i$

有一种可能的思维路径：不能分解质因数就不能统筹全局，而和统筹全局相对的就是增量法，所以倒序处理即可

从 $i+1$ 开始的后缀推到 $i$ 开始的后缀需要先找到 $a_i$ 包含的质因子中指数是后缀最大值的那些，那么令 $t=a_i$ 并遍历所有 $j$ 使 $t\leftarrow \frac{t}{gcd(a_i,b_j)}$

$t$ 中剩余的质因子就是 $b_i$ 应该包含的质因子，将其指数调整成 $a_i$ 唯一分解中该因子指数即可，这个过程可以通过令 $b_i\leftarrow b_i\times gcd(a_i,t),a_i\leftarrow \frac{a_i}{gcd(a_i,t)}$ 来实现，也可以直接求 $gcd(v^{\log_2 a_i},a_i)$ （每个因子指数最大是 $\log_2 a_i$，但是精度不知道能不能保证）赋给 $b_i$

这个过程复杂度是 $\Theta(n^2\log n)$ ，但是 $\prod_{j<i}b_j\mod a_i$ 的值就包含了所有 $b_i$ 中包含的质因子，将其当做 $t$ 也可以求出来合法的 $b_j$

求出 $b_i$ 后需要将后缀中有 $b_i$ 中含有的因子消去，通过二分 $gcd(\prod_{k=i+1}^j b_k\mod b_i)$ 变化的所有 $j$ 得到需要修改的位置，显然位置只有 $\log V$ 个，总复杂度也是合理的

本题比较巧妙的一点就是使用了 $\mod x$ 后再取 $gcd$ 仍然保留了因子信息这个性质